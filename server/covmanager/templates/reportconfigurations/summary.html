{% extends 'layouts/layout_base.html' %}

{% block css.custom %}
  <link rel='stylesheet' href='/static/css/covmanager.css'>
  <style>
    text {
      font: 12px sans-serif;
    }
    tspan:last-child {
      font-size: 10px;
      fill-opacity: 0.8;
    }
    .node rect {
      shape-rendering: crispEdges;
      stroke: #2B2B2B;
    }
    .node--hover rect {
      stroke: #000000;
    }
  </style>
{% endblock css.custom %}

{% block body_content %}
<div id="main" class="panel panel-default">
  <div class="panel-heading"><i class="glyphicon glyphicon-dashboard"></i> Report Summary</div>
  <template v-if="loading">
    <div class="loader">
    </div>
    <template v-if="loading_incomplete">
      <div class="loader-msg">
        <span>The requested summary is being generated by the server, please wait...</span>
      </div>
    </template>
  </template>
  <template v-else>
  <div class="panel-body">
    <button @click="refresh()" class="btn btn-default">Refresh this Report Summary</button>
    <button @click="textual()" class="btn btn-default">View Textual Report</button>
  </div>
  <div class="panel-body">
  <div id="graph-container" style="margin: 0 auto; width: 1280px;">
    <template>
    <div style="padding-bottom: 20px;">
      <span>Maximum Display Depth: </span>
      <vue-slider ref="slider" v-model="chart.level" v-bind:max="chart.maxlevel" v-bind:piecewise="true" v-bind:piecewise-label="true"></vue-slider>
    </div>
    </template>
  <svg width="1280" height="1024"></svg>
  </div>
  </div>
  </template>
</div>

<script>
let URLS = {
  rs_api : '{% url 'covmanager:collections_reportsummary_api' collectionid %}',
  html_url : '{% url 'covmanager:collections_reportsummary_html_list' collectionid %}',
}

let pmanager = new HashParamManager()

let covmanager = new Vue({
  el: '#main',
  components: {
    vueSlider,
  },
  data: {
    csrftoken: "",
    loading: false,
    loading_incomplete: false,
    chart: {
      data: {},
      level: 0,
      maxlevel: 0,
      slider: {
        initialized: false,
      },
    }
  },
  watch: {
    'chart.data': function() {
      this.draw()
    },
    'chart.level': function() {
      this.draw()
    },
    'chart.maxlevel': function() {
      if (!this.chart.slider.initialized) {
        this.chart.level = this.chart.maxlevel
        this.chart.slider.initialized = true
      }
    }
  },
  created: function () {
    this.csrftoken = getCSRFToken()
    this.fetch()
  },
  methods: {
    fetch: _.throttle (function () {
      this.loading = true
      fetch(URLS.rs_api, {
        method: 'GET',
        credentials: 'same-origin'
      }).then(response => {
        if (response.ok) {
          if (response.status == 204) {
            // Summary is still being processed, retry in a few
            setTimeout(this.fetch, 1000)
            this.loading_incomplete = true
            return;
          }
          this.loading_incomplete = false
          this.loading = false
          return response.json()
        }
        sweetAlert('Oops', E_SERVER_ERROR, 'error')
        this.loading = false
      }).then(json => {
        if (json) {
          if ("error" in json) {
            sweetAlert('Configuration Error', json["error"], 'error')
            return
          }

          if ("warning" in json) {
            sweetAlert('Configuration Warning', json["warning"], 'warning')
          }

          this.chart.slider.initialized = false
          this.chart.data = json
        }
      })
    }, 500),
    refresh: function() {
      var self = this

      return fetch(URLS.rs_api, {
        method: 'POST',
        credentials: 'same-origin',
        headers: {
          "Content-Type": "application/json; charset=utf-8",
          "X-Requested-With": "XMLHttpRequest",
          "X-CSRFToken": this.csrftoken
        },
        body: "",
      })
      .then(response => {
        if (response.ok) {
          return response.json()
        }
        sweetAlert('Oops', E_SERVER_ERROR, 'error')
      })
      .then(() => {
        self.fetch()
      })
    },
    textual: function() {
      window.open(URLS["html_url"], '_blank').focus()
    },
    draw: function() {
      let self = this
      let data = this.chart.data
      if (!data) return;

      let svg = d3.select("svg")
      let width = +svg.attr("width")
      let height = +svg.attr("height")

      svg.remove();

    	d3.select("#graph-container")
            .append("svg:svg")
            .attr("width", width)
            .attr("height", height)

      svg = d3.select("svg")

      let treemap = d3.treemap()
                      .tile(d3.treemapSquarify.ratio(1))
                      .size([width, height])
                      .round(true)
                      .paddingOuter(5)
                      .paddingTop(20)
                      .paddingInner(5)

      let step = d3.scaleLinear()
                   .domain([1, 8])
                   .range([1, 100]);

      // Color interpolation from red to green
      let color = d3.scaleLinear()
                    .domain([1, step(2), step(3), step(4), step(5), step(6), step(7), 100])
                    .range(['#d73027', '#f46d43', '#fdae61', '#fee08b', '#d9ef8b', '#a6d96a', '#66bd63', '#1a9850'])
                    .interpolate(d3.interpolateHcl);

      let format = d3.format(",d");

      let root_node = null
      let root = d3.hierarchy(data).eachBefore(function(d) {
        if (!d.parent) {
          root_node = d
        }

        d.data.id = (d.parent ? d.parent.data.id + "." : "") + d.data.name
        d.id = d.data.id

        if (d.depth > self.chart.maxlevel) {
          self.chart.maxlevel = d.depth
        }

        let level = parseInt(self.chart.level)
        if (level >= 0) {
          if (d.depth > level) {
            d.id = ""
            d.value = 0
            return
          }
        }

        if (d.parent && d.parent.min_val) {
          // We use linesTotal for size calculation but if the size drops below
          // a certain threshold, we just cap to avoid the box getting too small.

          // Our current strategy is to look at the root and use a fraction of that,
          // independent of the depth of the node. This has the advantage that all
          // capped rectangles are about the same area.
          //
          // However, with this approach alone, it can easily happen that the sum
          // of the child boxes (by far) exceeds the available space in the parent
          // box. So we refine the minimum value per box that has children by looking
          // at the available space and the amount of boxes that need to be "promoted".
          // Based on these numbers, we recalculate the minimum child value for each
          // parent box and assign it here.

          if (d.data.linesTotal < d.parent.min_val) {
            d.value = d.parent.min_val
          } else {
            d.value = d.data.linesTotal
          }
        } else {
          d.value = d.data.linesTotal
        }

        if (d.children) {
          // This is the minimum child value calculation as explained in the comment above.
          let ref_size = root_node.data.linesTotal
          let max_factor = 0.015
          let min_val = ref_size * max_factor

          if (d.children.length * min_val > d.value) {
            let avail = d.value
            let min_cnt = 0
            for (let child of d.children) {
              if (child.value > min_val) {
                avail -= child.value
              } else {
                min_cnt++
              }
            }
            min_val = avail / min_cnt;
          }

          d.min_val = min_val
        }

      }).sort(function(a, b) { return b.height - a.height || b.value - a.value; })

      treemap(root)

      let cell = svg
        .selectAll(".node")
        .data(root.descendants())
        .enter().append("g")
        .attr("transform", function(d) { return "translate(" + d.x0 + "," + d.y0 + ")"; })
        .attr("class", "node")
        .each(function(d) { d.node = this; })
        .on("mouseover", hovered(true))
        .on("mouseout", hovered(false))

      cell.append("rect")
          .attr("id", function(d) { return "rect-" + d.id; })
          .attr("width", function(d) { return d.x1 - d.x0; })
          .attr("height", function(d) { return d.y1 - d.y0; })
          .style("fill", function(d) {
            return color(Math.floor(d.data.coveragePercent))
          })

      cell.append("clipPath")
          .attr("id", function(d) { return "clip-" + d.id; })
          .append("use")
          .attr("xlink:href", function(d) { return "#rect-" + d.id + ""; })

      function createTopLabelData(d) {
        // Add a non-breaking space if we have children, so we don't wrap
        let nbs = d.children ? "\xa0" : "";

        let id = d.id.substring(d.id.lastIndexOf(".") + 1)
        let splitid = [ id ];

        // Assume that each letter (on average) fits within 8px. Yes, this is a hack.
        let max_len = Math.floor((d.x1 - d.x0) / 8);

        if (id.length > max_len) {
          splitid = id.split(/(?=[ ])/g)
          let new_splitid = []
          for (let sid of splitid) {
            if (new_splitid.length == 0 || new_splitid[new_splitid.length - 1].length + sid.length > max_len) {
              new_splitid.push(sid.trim())
            } else {
              new_splitid[new_splitid.length - 1] += sid
            }
          }
          splitid = new_splitid;
        }

        // TODO: This can be improved further by breaking on [a-z][A-Z]
        // a second time if a single word is still exceeding max length
        //for (let idx = splitid.length - 1 ; idx >= 0; idx--) {
        //  if (splitid[idx].length > max_len) {
        //
        //  }
        //}

        return splitid.concat(nbs + format(d.data.linesTotal))
      }

      cell.append("text")
          .attr("clip-path", function(d) { return "url(#clip-" + d.id + ")"; })
          .filter(function(d) { return d.children; })
          .selectAll("tspan")
          .data(createTopLabelData)
          .enter().append("tspan")
          .attr("x", function(d, i) {
            return i ? null : 5;
          })
          .attr("y", function(d, i) {
            return 15;
          })
          .text(
            function(d) { return d; }
          );

      cell.append("text")
          .attr("clip-path", function(d) { return "url(#clip-" + d.id + ")"; })
          .filter(function(d) { return !d.children; })
          .selectAll("tspan")
          .data(createTopLabelData)
          .enter().append("tspan")
          .attr("x", function(d, i) {
            return 5;
          })
          .attr("y", function(d, i) {
            return 15 /* Distance to top edge */ + i * 12 /* Should be equal to font size */;
          })
          .text(function(d) { return d; })

      cell.append("text")
          .attr("x", function(d) { return (d.x1 - d.x0) / 2; })
          .attr("y", function(d) { return (d.y1 - d.y0) / 2; })
          .attr("text-anchor", "middle")
          .text(function(d) { return d.data.coveragePercent + "%"; })
          .style("opacity", function(d) {
            // Ensure we have at least space for the text plus 2 px so it doesn't touch the border
            return (d.x1 - d.x0 - 2) > this.getComputedTextLength() ? 1 : 0;
          });

      cell.append("title")
          .text(function(d) {
            data = [
              d.id.substring(d.id.lastIndexOf(".") + 1), /* Name */
              "",
              `${format(d.data.linesTotal)} total lines`,
              `${d.data.coveragePercent}% coverage`,
            ]

            return data.join("\n")
          });

      function hovered(hover) {
        return function(d) {
          d3.selectAll(d.ancestors().map(function(d) { return d.node; }))
            .classed("node--hover", hover)
            .select("rect")
            .attr("width", function(d) { return d.x1 - d.x0 - hover; })
            .attr("height", function(d) { return d.y1 - d.y0 - hover; });
        };
      }
    },
  },
})

// This updates our path variable in the Vue whenever the hash changes, which again triggers a reload of the data.
window.onhashchange = function() {
  pmanager.update_state()
}
</script>

{% endblock body_content %}
